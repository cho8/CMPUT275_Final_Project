def auto_eat(remain, inv_list, value,memo = None):
    """
    Finds the maximum possible "value" of troops that can be loaded
    in to the remaining space of a transport.

    Input:
     transport - The transport unit to be loaded.
     unit_list - The list of units that can be loaded onto transport.
       You may assume that these units are non-transport ground units
       that are already on the same team as the transport, have not
       moved this turn, and can reach the transport with a single move.
     value - a function that maps a unit to some value

    Output:
     A list of units from unit_list. Do NOT load them into the transport
     here, just compute the list of units with maximum possible value whose
     total size is at most the remaining capacity of the transport.

     The calling function from gui.py will take care of loading them.

    Target Complexity:
     It is possible to implement this method to run in time
     O(n * C) where n is the number of units in unit_list and C
     is the remaining capacity in the transport. Remember, the capacity
     of a transport and the sizes of the units are all integers.

    Actual Complexity:
    We are fairly certain we have fail close to O(n*C) complexity.  I have made a note 
    below in the case of when we use a list_value function, where we know it may make the 
    complexity slightly larger. 
    """
    if memo is None:
        memo = {}
    if inv_list == []:
        return []
    
    #The current capacity of the transport in this specific layer.
    max_remain = remain

    #The maximum valued list for this specific layer
    max = list()
    layer = tuple(inv_list)

    maxvalue = 0
    for i in inv_list:
        sub_sol = list()
        copy = inv_list.copy()
        copy.remove(i)
        layer = tuple(copy)
        
        #If we have removed the last unit, return an empty list.
        if layer == tuple([]):
            return []

        #Check if we already have a max value list for this layer.
        if layer not in memo:
            if value(i) <= remain:
                remain -= value(i)
                sub_sol.append(i)
                sub_sol.extend(auto_eat(remain,copy,value,memo))
                
                curr_val = list_value(sub_sol,lambda x: x.size)

                if curr_val > maxvalue:
                    maxvalue = curr_val
                    max = sub_sol

        remain = max_remain
        inv_list.remove(i)

        #After iterating through all possibilities in unit_list, assign the max value
        #list for the layer to memo[layer]
        memo[layer] = max
    
    return memo[layer]

#returns the total value of the list passed in based on the function 'value' that is
#taken as an argument.
def list_value(list,value):
   total = 0
   for val in list:
      total += value(val)
   return total